# CLAUDE.md ‚Äî AI Assistant Bot Project Guide

## Project Overview

**Jimmy** is a modular AI personal assistant bot for Telegram (later multi-platform). It uses natural language understanding to help users manage tasks, notes, calendar, and more through voice or text messages.

**Current Status**: M1 ‚Äî Core Assistant in progress.

## Tech Stack

- **Runtime**: Node.js + TypeScript
- **Bot Framework**: grammY (Telegram)
- **Database**: Supabase (PostgreSQL)
- **LLM**: Anthropic Claude API (intent routing + chat)
- **Voice**: OpenAI Whisper API (transcription)
- **Deploy**: Railway

## Core Architecture Principles

### 1. Vertical Feature Structure
```
src/
‚îú‚îÄ‚îÄ bot/          # Telegram-specific (middleware, handlers)
‚îú‚îÄ‚îÄ core/         # Platform-independent (LLM, skills, session)
‚îú‚îÄ‚îÄ features/     # Feature modules (users, tasks, notes, chat)
‚îî‚îÄ‚îÄ db/           # Database client & migrations
```

Each feature owns its types, repo, skill, and handlers in one folder.

### 2. Skill System
- Features register "skills" with intents (e.g., `create_task`, `chat`)
- LLM router receives skill descriptions and routes messages to correct skill
- Adding/removing features = register/unregister skills
- Bot never claims to do what it can't

### 3. LLM-Native Language Support
- NO i18n translation files
- User selects language during onboarding
- All responses generated by Claude in user's language via system prompt
- Supports 50+ languages out of the box

### 4. Confirmation System
- Read operations: immediate response
- Write operations (create/update/delete): require user confirmation
- Inline keyboards with [Confirm] [Cancel]

### 5. Message Pipeline
```
Incoming ‚Üí Logger ‚Üí Rate Limit ‚Üí Auth ‚Üí Onboarding Guard ‚Üí
Voice Transcription (if voice) ‚Üí Confirmation Check ‚Üí
LLM Router ‚Üí Skill Dispatch ‚Üí Save History ‚Üí Response
```

## Planning Documents

Reference files in `.claude/` folder:
- **architecture.md** ‚Äî System architecture, patterns, principles
- **roadmap.md** ‚Äî All milestones and features overview
- **milestone1.md** ‚Äî Detailed M1 tasks (current focus)
- **technical-plan.md** ‚Äî Step-by-step implementation guide

## Documentation Rules

### 1. Update Planning Files When Deviating
When implementation deviates from the plan (different approach, new requirements, skipped steps):
- Update the relevant file in `.claude/` folder
- Document WHY the change was made
- Keep technical-plan.md aligned with actual implementation
- Mark completed checkboxes in milestone files

### 2. Create Module Documentation
When implementing a new module/feature:
- Create `docs/` folder if it doesn't exist
- Add `docs/<module-name>.md` with:
  - Purpose and overview
  - API/interface documentation
  - Usage examples
  - Dependencies and integration points
  - Testing approach
- Update docs when module behavior changes

### 3. Keep CONTEXT.md Current
After each work session, update `CONTEXT.md` with:
- What was accomplished
- Current milestone progress
- Next steps
- Blockers or decisions needed

### 4. Track User Action Items
**IMPORTANT**: The user wants to complete this project without writing code themselves.

After each implementation session, create or update `TASKS_FOR_USER.md` with:
- ‚úÖ Clear checkboxes for each action item needed from the user
- üìã Step-by-step instructions (numbered, detailed)
- üîó Links to relevant services/documentation
- ‚ö†Ô∏è Prerequisites or things to prepare
- üìù Exact values/text to copy-paste where possible

**Examples of user tasks:**
- Creating accounts (Telegram Bot, Supabase, Railway, Anthropic, OpenAI)
- Getting API keys and tokens
- Setting up environment variables (with exact .env format)
- Configuring deployment settings
- Running database migrations
- Testing specific features

**Format:**
- Group tasks by milestone/phase
- Mark completed tasks with ‚úÖ
- Use clear headings and sections
- Include "Why this is needed" context
- Provide troubleshooting tips

Update this file EVERY TIME user action is required before you can proceed.

## Development Workflow

1. **Check CONTEXT.md** for current state
2. **Check TASKS_FOR_USER.md** for any pending user actions
3. **Reference technical-plan.md** for next steps
4. **Implement following architecture patterns**
5. **Update planning docs** if deviating
6. **Create/update module docs** for new features
7. **Update TASKS_FOR_USER.md** with any new user action items
8. **Update CONTEXT.md** when done

## Testing Rules

### Mandatory Testing
- **Every module with logic** (repos, middleware, handlers, services, skills) MUST have tests
- Write tests **as part of the implementation step**, not as a separate phase at the end
- Run tests yourself after writing them ‚Äî never leave untested code behind

### Test Structure
- **Framework**: Vitest
- **Location**: Co-locate tests next to source files as `<name>.test.ts` (e.g., `user.repo.ts` ‚Üí `user.repo.test.ts`)
- **Naming**: Use descriptive `describe`/`it` blocks that read like specs
- **Organization**: One `describe` per function/method, group related cases with nested `describe`

### Test Quality
- **Mock external dependencies** (Supabase, APIs, grammY context) ‚Äî never hit real services in tests
- **Test behavior, not implementation** ‚Äî focus on inputs/outputs and side effects
- **Cover edge cases**: invalid input, empty results, error paths, boundary conditions
- **Keep tests independent** ‚Äî no shared mutable state between tests, each test sets up its own fixtures
- **Use factories/helpers** for repetitive test data setup ‚Äî put shared helpers in `src/test/helpers.ts`

### What to Test
- Repository functions: CRUD operations, error handling, edge cases
- Middleware: context mutation, next() calls, guard conditions
- Skills/handlers: correct routing, response format, error recovery
- Pure logic: validation, transformations, calculations

### What NOT to Test
- Simple type definitions or interfaces
- Direct re-exports
- Framework boilerplate (bot.start, pino config)

## Key Patterns to Follow

- **Mock LLM mode**: `MOCK_LLM=true` for development without API calls
- **Env validation**: Use zod, crash early if config invalid
- **Error handling**: Never crash bot, always give user a way forward
- **Platform independence**: Core/features don't import from bot/
- **Flat structure**: Most folders have 1-4 files max
- **Security**: Env-only secrets, RLS on all tables, encrypted OAuth tokens

## Current Milestone: M1 ‚Äî Core Assistant

Goal: Bot is deployed, understands voice and text, onboards users, routes intents via LLM, maintains chat history, confirms mutations.

See `claude/milestone1.md` for detailed tasks and `claude/technical-plan.md` for step-by-step guide.
